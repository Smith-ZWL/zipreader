第七章  数据结构（下）
7.6 树和二叉树 
树型结构是一类重要的非线性结构。树型结构是结点之间有分支，并且具有层次关系的
结构，它非常类似于自然界中的树。树结构在客观世界国是大量存在的，例如家谱、行政组
织机构都可用树形象地表示。树在计算机领域中也有着广泛的应用，例如在编译程序中，用
树来表示源程序的语法结构；在数据库系统中，可用树来组织信息；在分析算法的行为时，
可用树来描述其执行过程。等等。 
6.1  树的定义和基本术语  
树是 n（n≥0）个结点的有限集合 T。当 n=0时，称为空树；当 n>0时， 该集合满足如
下条件： 
(1) 其中必有一个称为根（root）的特定结点，它没有直接前驱，但有零个或多个直接
后继。 
(2) 其余 n-1 个结点可以划分成 m（m≥0）个互不相交的有限集 T1，T2，T3，…，Tm，
其中 Ti 又是一棵树，称为根 root的子树。 每棵子树的根结点有且仅有一个直接前驱，但
有零个或多个直接后继。  
图 6.1  树的图示方法 
ADT Tree 
    数据对象 D：一个集合，该集合中的所有元素具有相同的特性。 
    数据关系 R： 若 D为空集，则为空树。 若 D中仅含有一个数据元素，则 R为空集，否
则 R={H}，H 是如下的二元关系：  
(1) 在 D中存在唯一的称为根的数据元素 root， 它在关系 H下没有前驱。 
(2)若 D-{ root }≠ф，则存在 D-{ root }的一个划分 D1，D2…Dm ( m>0 ) 对任意 j
≠k ( 1≤j, k≤m ) 有 Dj∩Dk=ф,且对任意的 i( 1≤i≤m ) 唯一存在数据元素 xi﹥∈H. 
(3)对应于 D-{ root }的划分，H-{ <root,x1>,…< root,xm> }有唯一的一个划分 H1，
H2，…,Hm ( m>0 ), 对任意 j≠k ( 1≤j, k≤m )有 Hj∩Hk=ф,且对任意 i(1≤i≤m ) ,H1
是 Di上的二元关系，（ Di, { Hi } ）是一棵符合本定义的树，成为根 root的子树。}  
树的基本术语   
· 结点：包含一个数据元素及若干指向其它结点的分支信息。
· 结点的度：一个结点的子树个数称为此结点的度。 
· 叶子结点：度为 0的结点，即无后继的结点，也称为终端结点。
· 分支结点：度不为 0 的结点，也称为非终端结点。 
· 孩子结点：一个结点的直接后继称为该结点的孩子结点。在图 6.1中， B、C是 A的
孩子。  
   · 双亲结点：一个结点的直接前驱称为该结点的双亲结点。在图 6.1 中，A 是 B、C的
双亲。  
   · 兄弟结点：同一双亲结点的孩子结点之间互称兄弟结点。在图 6.1中，结点 H、I、 J
互为兄弟结点。  
·堂兄弟：双亲在同一层的结点互为堂兄弟。         
   ·祖先结点：一个结点的祖先结点是指从根结点到该结点的路径上的所有结点。在图 6.1
中，结点 K的祖先是 A、B、E。  
   ·子孙结点：以某结点为根的子树中的任一结点都称为该结点的子孙 。在图 6.1中，结
点 D的子孙是 H、I、 J、 M。  
   ·结点的层次：从根结点开始定义，根结点的层次为 1，根的直接后继的层次为 2，依此
类推。  
   ·树的度： 树中所有结点的度的最大值。 
   ·树的高度（深度）： 树中所有结点的层次的最大值。  
   ·有序树：在树 T 中，如果各子树 Ti 之间是有先后次序的，则称为有序树。 否则称为
无序树 。 
   ·森林： m（m≥0）棵互不相交的树的集合。将一棵非空树的根结点删去，树就变成一
个森林；反之，给森林增加一个统一的根结点，森林就变成一棵树。  
6.2   二叉树的定义  
6.2.1 二叉树的定义  
定义：我们把满足以下两个条件的树形结构叫做二叉树（Binary Tree）：  
  （1） 每个结点至多只有二棵子树（即度都不大于 2）；  
  （2）二叉树的子树有左右之分，其次序不能任意颠倒。   
    由此定义可以看出，一个二叉树中的每个结点只能含有 0、 1或 2个孩子，而且每个孩
子有左右之分。我们把位于左边的孩子叫做左孩子，位于右边的孩子叫做右孩子。  
 
图 6.3  给出了二叉树的五种基本形态。 
6.2.2  二叉树的性质  
性质 1: 在二叉树的第 i层上至多有 2i-1个结点(i≥1)。  
    证明： 用数学归纳法。  
    归纳基础：当 i=1时，整个二叉树只有一根结点，此时 
2i-1=20=1，结论成立。 
    归纳假设：假设 i=k时结论成立，即第 k层上结点总数最多为 2k-1个。   现证明当
i=k+1时， 结论成立：  
    因为二叉树中每个结点的度最大为 2，则第 k+1层的结点总数最多为第 k层上结点最大
数的 2倍，即 2×2k-1=2(k+1)-1，故结论成立。  
性质 2: 深度为 k的二叉树至多有 2k-1个结点（k≥1）。  
     证明：因为深度为 k 的二叉树，其结点总数的最大值是将二叉树每层上结点的最大值
相加，所以深度为 k的二叉树的结点总数至多为  
 
故结论成立。  
性质 3: 对任意一棵二叉树 T，若终端结点数为 n0，而其度数为 2的结点数为 n2，则 n0=n2+1
。 
     证明：设二叉树中结点总数为 n， n 1为二叉树中度为 1的结点总数。    因为
二叉树中所有结点的度小于等于 2，所以有 n=n0+n1+n2 
设二叉树中分支数目为 B， 因为除根结点外， 每个结点均对应一个进入它的分支，所
以有：n=B+1。又因为二叉树中的分支都是由度为 1和度为 2的结点发出， 所以分支数目为：
B=n1+2n2。整理上述两式可得到： 
 n=B+1=n1+2n2+1 
    将 n=n0+n1+n2代入上式，得出 n0+n1+n2=n1+2n2+1，整理后得 n0=n2+1，故结论成立。  
满二叉树：  
深度为 k 且有 2k-1 个结点的二叉树。在满二叉树中，每层结点都是满的，即每层结点
都具有最大结点数。 图 6.3(a)所示的二叉树，即为一棵满二叉树。满二叉树的顺序表示，
即从二叉树的根开始， 层间从上到下， 层内从左到右，逐层进行编号（1， 2， …， n）。
例如图 6.3(a)所示的满二叉树的顺序表示为(1， 2， 3， 4， 5， 6， 7， 8， 9， 10， 
11， 12， 13， 14， 15)。  
完全二叉树： 
    深度为 k，结点数为 n的二叉树，如果其结点 1~n的位置序号分别与满二叉树的结点 1~n
的位置序号一一对应，则为完全二叉树， 如图 6.3(b)所示。  
    满二叉树必为完全二叉树， 而完全二叉树不一定是满二叉树。  
    完全二叉树的特点： 
    ⑴叶子只能在层次最大的两层上出现； 
    ⑵对任意一个结点，右分支下的子孙的最大层次为 L，则左分支为 L或 L+1 。 
  
图 6.3  满二叉树与完全二叉树 
性质 4：具有 n个结点的完全二叉树的深度为［log2n］+1。  
    证明：假设 n个结点的完全二叉树的深度为 k，根据性质 2可知，k-1层满二叉树的结
点总数为：n1=2k-1-1；k 层满二叉树的结点总数为： n2=2k-1。显然有 n1<n≤n2，进
一步可以推出 n1+1≤n<n2+1。 
    将 n1=2k-1-1和 n2=2k-1 代入上式，可得 2k-1≤n<2k，即 k-1≤log2n<k。   因为 k
是整数，所以 k-1=［log2n］，k=［log2n］+1, 故结论成立。   
性质 5:  对于具有 n个结点的完全二叉树， 如果按照从上到下和从左到右的顺序对二叉树
中的所有结点从 1开始顺序编号， 则对于任意的序号为 i的结点有：  
    （1） 如 i=1，则序号为 i的结点是根结点， 无双亲结点； 如 i>1， 则序号为 i的结
点的双亲结点序号为［i/2］。  
    （2） 如 2×i>n，则序号为 i的结点无左孩子；如 2×i≤n，则序号为 i的结点的左孩
子结点的序号为 2×i。  
    （3） 如 2×i＋1>n，则序号为 i的结点无右孩子；如 2×i＋1≤n， 则序号为 i 的结
点的右孩子结点的序号为 2×i＋1。  
可以用归纳法证明其中的（2）和（3）：  
     当 i=1 时，由完全二叉树的定义知，如果 2×i=2≤n，说明二叉树中存在两个或两个
以上的结点，所以其左孩子存在且序号为 2； 反之，如果 2>n，说明二叉树中不存在序号为
2 的结点，其左孩子不存在。同理，如果 2×i+1=3≤n， 说明其右孩子存在且序号为 3；如
果 3>n，则二叉树中不存在序号为 3的结点， 其右孩子不存在。  
     假设对于序号为 j(1≤j≤i)的结点，当 2×j≤n时，其左孩子存在且序号为 2×j，当
2×j>n 时，其左孩子不存在；当 2×j+1≤n时， 其右孩子存在且序号为 2×j+1，当 2×j+1>n
时，其右孩子不存在。  
当 i=j+1 时，根据完全二叉树的定义， 若其左孩子存在， 则其左孩子结点的序号一定等于
序号为 j的结点的右孩子的序号加 1， 即其左孩子结点的序号等于 （2×j+1）+1=2（j+1）
=2×i， 且有 2×i≤n；如果 2×i>n， 则左孩子不存在。 若右孩子结点存在，则其右孩子
结点的序号应等于其左孩子结点的序号加 1，即右孩子结点的序号为 2×i+1，且有 2×i+1
≤n；如果 2×i+1>n，则右孩子不存在。 故（2）和（3）得证。  
由（2）和（3）我们可以很容易证明（1）。  
    当 i=1 时， 显然该结点为根结点，无双亲结点。当 i>1时，设序号为 i的结点的双亲
结点的序号为 m，如果序号为 i的结点是其双亲结点的左孩子，根据（2）有 i=2×m，即
m=i/2; 如果序号为 i的结点是其双亲结点的右孩子，根据（3）有 i=2×m+1， 即 m=（i-1）
/2=i/2-1/2，综合这两种情况，可以得到，当 i>1时， 其双亲结点的序号等于［i/2］。证
毕。  
6.2.3  二叉树的存储结构  
二叉树的结构是非线性的， 每一结点最多可有两个后继。 二叉树的存储结构有两种： 
    顺序存储结构和链式存储结构。  
1： 顺序存储结构 
    用一组地址连续的存储单元，依次自上而下，自左至右存储完全二叉树上的结点元素，
即将完全二叉树上编号为 i 的结点元素存储在数组的第 i –1个分量中。   
   
 
图 6.4  二叉树与顺序存储结构 
 
图 6.5  单支二叉树与其顺序存储结构 
 
2. 链式存储结构 
    对于任意的二叉树来说，每个结点只有两个孩子，一个双亲结点。我们可以设计每个结
点至少包括三个域：数据域、 左孩子域和右孩子：  
 
其中，LChild域指向该结点的左孩子，Data 域记录该结点的信息，RChild域指向该结
点的右孩子。 用 C语言这样声明二叉树的二叉链表结点的结构：  
typedef struct BiTNode 
{   TElemType data;  
struct BiTNode *LChild;  
struct BiTNode *RChild;  
}BiTNode,  *BiTree;  
有时，为了便于找到父结点，可以增加一个 Parent 域， Parent 域指向该结点的父结
点。 该结点结构如下：  
 
  
图 6.6 二叉树和二叉链表 
若一个二叉树含有 n 个结点，则它的二叉链表中必含有 2n 个指针域， 其中必有 n＋1
个空的链域。此结论证明如下：  
    证明：分支数目 B=n-1，即非空的链域有 n-1个，故空链域有 2n-(n-1)=n+1个。  
    不同的存储结构实现二叉树的操作也不同。如要找某个结点的父结点，在三叉链表中很
容易实现；在二叉链表中则需从根指针出发一一查找。可见，在具体应用中，需要根据二叉
树的形态和需要进行的操作来决定二叉树的存储结构。  
6.3  二叉树的遍历与线索化  
6.3.1  二叉树的遍历  
 
图 6.7  二叉树结点的基本结构 
遍历二叉树：按某种搜索路径，使二叉树每个结点均被访问一次，且仅被访问一次。访
问的含义很广。遍历需寻找某中规律，使二叉树的结点能排列在一个线形队列上 。        
    我们用 L、D、R分别表示遍历左子树、访问根结点、 遍历右子树， 那么对二叉树的遍
历顺序就可以有六种方式：  
(1) 访问根，遍历左子树，遍历右子树（记做 DLR）。  
(2) 访问根，遍历右子树，遍历左子树（记做 DRL）。  
(3) 遍历左子树，访问根，遍历右子树（记做 LDR）。  
(4) 遍历左子树，遍历右子树，访问根（记做 LRD）。  
(5) 遍历右子树，访问根，遍历左子树（记做 RDL）。  
(6) 遍历右子树，遍历左子树，访问根（记做 RLD）。  
注意：先序、中序、后序遍历是递归定义的， 即在其子树中亦按上述规律进行遍历。  
下面就分别介绍三种遍历方法的递归定义。  
· 先序遍历（DLR）操作过程：  
   若二叉树为空，则空操作，否则依次执行如下 3个操作：  
   (1) 访问根结点；  
   (2) 按先序遍历左子树；  
   (3) 按先序遍历右子树。  
· 中序遍历（LDR）操作过程：  
   若二叉树为空，则空操作，否则依次执行如下 3个操作：  
   (1) 按中序遍历左子树；  
   (2) 访问根结点；  
   (3) 按中序遍历右子树。  
· 后序遍历（LRD）操作过程：  
   若二叉树为空，则空操作，否则依次执行如下 3个操作：  
   (1) 按后序遍历左子树；  
   (2) 按后序遍历右子树；  
   (3) 访问根结点。  
对于如图 6.8 所示的二叉树， 其先序、 中序、 后序遍历的序列如下：  
先序遍历：   A、 B、 D、 F、 G、 C、 E、 H 。  
中序遍历：   B、 F、 D、 G、 A、 C、 E、 H 。  
后序遍历：   F、 G、 D、 B、 H、 E、 C、 A 。  
 
最早提出遍历问题是对存储在计算机中的表达式求值。例如：（a+b*c）-d/e。该表达
式用二叉树表示如图 6.9所示。当我们对此二叉树进行先序、中序、后序遍历时，便可获得
表达式的前缀、 中缀、 后缀书写形式：  
前缀： -+a*bc/de  
中缀： a+b*c-d/e  
后缀： abc*+de/-  
    其中中缀形式是算术表达式的通常形式，只是没有括号。 前缀表达式称为波兰表达式。
算术表达式的后缀表达式被称作逆波兰表达式。 在计算机内，使用后缀表达式易于求值。  
 
图 6.9  算术式的二叉树表示 
 
7.7 图 
 
7.1 图的定义与基本术语  
7.1.1 图的定义  
图(Graph)是一种网状数据结构， 其形式化定义如下：  
Graph=（V，R） 
V={x|x∈DataObject} 
R={VR} 
VR={<x， y>|P（x， y）∧（x， y∈V）} 
    DataObject 为一个集合，该集合中的所有元素具有相同的特性。V中的数据元素通常称
为顶点（vertex），VR是两个顶点之间关系的集合。P（x，y）表示 x和 y之间有特定的关
联属性 P。  
    若<x，y>∈VR，则<x， y>表示从顶点 x到顶点 y的一条弧（arc），并称 x为弧尾（tail）
或起始点，称 y为弧头（head）或终端点，此时图中的边是有方向的，称这样的图为有向图。 
    若<x， y>∈VR， 必有<y， x>∈VR，即 VR 是对称关系，这时以无序对（x， y）来代
替两个有序对，表示 x和 y之间的一条边（edge），此时的图称为无向图。  
 
基本术语  
1:完全图、稀疏图与稠密图 
    我们设 n表示图中顶点的个数，用 e表示图中边或弧的数目，并且不考虑图中每个顶点
到其自身的边或弧。即若<vi，vj>∈VR，则 vi≠vj。 
    对于无向图而言，其边数 e的取值范围是 0~n（n-1）/2。我们称有 n（n-1）/2条边（图
中每个顶点和其余 n-1个顶点都有边相连）的无向图为无向完全图。 
    对于有向图而言，其边数 e的取值范围是 0~n（n-1）。我们称有 n（n-1）条边（图中
每个顶点和其余 n-1个顶点都有弧相连）的有向图为有向完全图。  
    对于有很少条边的图（e<n logn）称为稀疏图，反之称为稠密图。  
2. 子图 
     设有两个图 G=（V，{E}）和图 G′=（V′，{E′}）, 若 V′ V且 E E, 则称图 G′
为 G的子图。  
 
3. 邻接点  
     对于无向图 G=（V， {E}），如果边（v，v′）∈E， 则称顶点 v，v′互为邻接点，
即 v，v′相邻接。边（v， v′）依附于顶点 v和 v′，或者说边（v， v′）与顶点 v和 v′
相关联。  
    对于有向图 G=（V， {A}）而言，若弧<v，v′>∈A， 则称顶点 v 邻接到顶点 v′，顶
点 v′邻接自顶点 v，或者说弧<v， v′>与顶点 v和 v′相关联。  
4. 度、入度和出度 
    对于无向图而言，顶点 v 的度是指和 v相关联边的数目，记作（v）。例如：图 7.1中
G2中顶点 v3的度是 3，v1 的度是 2； 
    在有向图中顶点 v的度有出度和入度两部分，其中以顶点 v为弧头的弧的数目成为该顶
点的入度，记作 ID（v），以顶点 v 为弧尾的弧的数目称为该顶点的出度，记作 OD（v）,
则顶点 v的度为 TD（v）=ID（v）+ OD（v）。例如：图 G1中顶点 v1的入度是 ID(v1)=1，
出度 OD(v1)=2,顶点 v1 的度 TD(v1)=ID(v1)+OD(v1)=3。一般地，若图 G 中有 n 个顶点，e
条边或弧，则图中顶点的度与边的关系如下：  
 
5. 权与网 
    在实际应用中，有时图的边或弧上往往与具有一定意义的数有关，即每一条边都有与它
相关的数，称为权，这些权可以表示从一个顶点到另一个顶点的距离或耗费等信息。我们将
这种带权的图叫做带权图或网，如图 7.3所示。  
 
6. 路径与回路 
无向图 G=（V，{E}）中从顶点 v 到 v′的路径是一个顶点序列 vi0， vi1，vi2，…，
vin，其中（vij-1，vij）∈E，1≤j≤n。如果图 G 是有向图，则路径也是有向的，顶点序
列应满足<vij-1，vij>∈A， 1≤j≤n。路径的长度是指路径上经过的弧或边的数目。在一
个路径中，若其第一个顶点和最后一个顶点是相同的，即 v=v′，则称该路径为一个回路或
环。若表示路径的顶点序列中的顶点各不相同，则称这样的路径为简单路径。除了第一个和
最后一个顶点外，其余各顶点均不重复出现的回路为简单回路。  
 
7. 连通图 
    在无向图 G=（V，{E}）中，若从 vi 到 vj 有路径相通，则称顶点 vi 与 vj 是连通的。
如果对于图中的任意两个顶点 vi、vj∈V，vi，vj都是连通的，则称该无向图 G 为连通图。
例如：G2就是连通图。无向图中的极大连通子图称为该无向图的连通分量。在有向图 G=（V，
{A}）中，若对于每对顶点 vi、vj∈V 且 vi≠vj， 从 vi 到 vj 和 vj 到 vi 都有路径，则称
该有向图为强连通图。有向图的极大强连通子图称作有向图的强连通分量，如图 7.4所示。  
8. 生成树  
    一个连通图的生成树是一个极小连通子图，它含有图的全部顶点，只有 n-1条边（构成
树的最小分支树）若在一棵生成树上添加一条边必定构成一个环。 
    一棵有 n个顶点的生成树有且仅有 n-1条边。若 n个顶点小于 n-1条边，则必为非连通
图；多于 n-1条边一定有环，但仅有 n-1条边的图不一定生成树。 
    如果一个有向图恰有一个顶点的入度为 0，其余顶点入度为 1，则是一棵有向树，一个
有向树的生成森林。由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相
交的有向树的弧。  
 
7.2  图的遍历  
    从图中某一顶点出发访问图中每一个结点，且每个顶点仅被访问一次----图的遍历，是
图的连通性问题，拓扑排序，求关键路径等的基础。         
    图的遍历比起树的遍历要复杂得多。由于图中顶点关系是任意的，即图中顶点之间是多
对多的关系，图可能是非连通图，图中还可能有回路存在， 因此在访问了某个顶点后，可
能沿着某条路径搜索后又回到该顶点上。为了保证图中的各顶点在遍历过程中访问且仅访问
一次，需要为每个顶点设一个访问标志，因此我们为图设置一个访问标志数组 visited［n］，
用于标示图中每个顶点是否被访问过，它的初始值为 0(“假”)，表示顶点均未被访问；一
旦访问过顶点 vi，则置访问标志数组中的 visited［i］为 1(“真”)，以表示该顶点已访
问。  
 
7.3.1  深度优先搜索 
    深度优先搜索（Depth-First Search）是指按照深度方向搜索，它类似于树的先根遍历，
是树的先根遍历的推广。深度优先搜索连通子图的基本思想是：  
   （1） 从图中某个顶点 v0出发，首先访问 v0。  
   （2） 找出刚访问过的顶点 vi 的第一个未被访问的邻接点， 然后访问该顶点。以该顶
点为新顶点，重复本步骤，直到当前的顶点没有未被访问的邻接点为止。  
   （3）返回前一个访问过的且仍有未被访问的邻接点的顶点，找出并访问该顶点的下一个
未被访问的邻接点，然后执行步骤(2)。  
    采用递归的形式说明，则深度优先搜索连通子图的基本思想可表示为：  
   （1） 访问出发点 v0。  
   （2） 依次以 v0 的未被访问的邻接点为出发点，深度优先搜索图，直至图中所有与 v0
有路径相通的顶点都被访问。  
    若此时图中还有顶点未被访问，则另选图中一个未被访问的顶点作为起始点，重复上述
深度优先搜索过程，直至图中所有顶点均被访问过为止。  
    图给出了一个深度优先搜索的过程图示，其中实箭头代表访问方向，虚箭头代表回溯方
向，箭头旁边的数字代表搜索顺序，A为起始顶点。  
 
图的深度优先搜索过程图示  
 
    首先访问 A，然后按图中序号对应的顺序进行深度优先搜索。 图中序号对应步骤的解
释如下：  
   （1） 顶点 A的未访邻接点有 B、E、D， 首先访问 A的第一个未访邻接点 B；  
   （2） 顶点 B的未访邻接点有 C、E，首先访问 B的第一个未访邻接点 C；  
   （3） 顶点 C的未访邻接点只有 F，访问 F；  
   （4） 顶点 F没有未访邻接点，回溯到 C；  
   （5） 顶点 C已没有未访邻接点，回溯到 B；  
   （6） 顶点 B的未访邻接点只剩下 E，访问 E；  
   （7） 顶点 E 的未访邻接点只剩下 G，访问 G；  
   （8） 顶点 G 的未访邻接点有 D、H，首先访问 G的第一个未访邻接点 D； 
   （9） 顶点 D没有未访邻接点， 回溯到 G；  
   （10） 顶点 G的未访邻接点只剩下 H， 访问 H；  
   （11） 顶点 H的未访邻接点只有 I， 访问 I；  
   （12） 顶点 I没有未访邻接点， 回溯到 H；  
   （13） 顶点 H 已没有未访邻接点， 回溯到 G；  
   （14） 顶点 G 已没有未访邻接点， 回溯到 E；  
   （15） 顶点 E已没有未访邻接点， 回溯到 B；  
   （16） 顶点 B已没有未访邻接点， 回溯到 A。   
7.3.2 广度优先搜索  
     广度优先搜索（Breadth-First Search）是指照广度方向搜索，它类似于树的层次遍
历，是树的按层次遍历的推广。广度优先搜索的基本思想是：  
    （1） 从图中某个顶点 v0出发，首先访问 v0。  
    （2） 依次访问 v0的各个未被访问的邻接点。  
    （3） 分别从这些邻接点（端结点）出发，依次访问它们的各个未被访问的邻接点（新
的端结点）。访问时应保证：如果 vi和 vk为当前端结点，vi在 vk之前被访问， 则 vi的
所有未被访问的邻接点应在 vk 的所有未被访问的邻接点之前访问。重复（3）， 直到所有
端结点均没有未被访问的邻接点为止。  
 
图的广度优先搜索过程图示  
 
    分析上述算法，图中每个顶点至多入队一次，因此外循环次数为 n。当图 g采用邻接表
方式存储，则当结点 v出队后，内循环次数等于结点 v 的度。由于访问所有顶点的邻接点的
总的时间复杂度为 O(d0+d1+d2+:+dn-1)=O(e)， 因此图采用邻接表方式存储，广度优先搜
索算法的时间复杂度为 O(n+e)；当图 g 采用邻接矩阵方式存储，由于找每个顶点的邻接点
时，内循环次数等于 n，因此广度优先搜索算法的时间复杂度为 O(n2)。  
7.8 排序 
一、插入排序(Insertion Sort) 
1. 基本思想： 
每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有
序；直到待排序数据元素全部插入完为止。 
2. 排序过程：  
【示例】： 
[初始关键字] [49] 38 65 97 76 13 27 49 
    J=2(38) [38 49] 65 97 76 13 27 49 
    J=3(65) [38 49 65] 97 76 13 27 49 
    J=4(97) [38 49 65 97] 76 13 27 49 
    J=5(76) [38 49 65 76 97] 13 27 49 
    J=6(13) [13 38 49 65 76 97] 27 49 
    J=7(27) [13 27 38 49 65 76 97] 49 
    J=8(49) [13 27 38 49 49 65 76 97] 
 
1 
2Procedure InsertSort(Var R : FileType); 
3//对 R[1..N]按递增序进行插入排序, R[0]是监视哨// 
4  Begin 
5    for I := 2 To N Do //依次插入 R[2],...,R[n]// 
6    begin 
7      R[0] := R; J := I - 1; 
8      While R[0] < R[J] Do //查找 R 的插入位置// 
9       begin 
10        R[J+1] := R[J]; //将大于 R 的元素后移// 
11        J := J - 1 
12       end 
13      R[J + 1] := R[0] ; //插入 R // 
14    end 
15  End; //InsertSort // 
 
二、选择排序 
1. 基本思想： 
  每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数
列的最后，直到全部待排序的数据元素排完。 
2. 排序过程： 
【示例】： 
初始关键字 [49 38 65 97 76 13 27 49] 
第一趟排序后 13 ［38 65 97 76 49 27 49] 
第二趟排序后 13 27 ［65 97 76 49 38 49] 
第三趟排序后 13 27 38 [97 76 49 65 49] 
第四趟排序后 13 27 38 49 [49 97 65 76] 
第五趟排序后 13 27 38 49 49 [97 97 76] 
第六趟排序后 13 27 38 49 49 76 [76 97] 
第七趟排序后 13 27 38 49 49 76 76 [ 97] 
最后排序结果 13 27 38 49 49 76 76 97 
 
16 
17Procedure SelectSort(Var R : FileType); //对 R[1..N]进行直接选择排序 // 
18  Begin 
19    for I := 1 To N - 1 Do //做 N - 1 趟选择排序// 
20     begin 
21      K := I; 
22      For J := I + 1 To N Do //在当前无序区 R[I..N]中选最小的元素 R[K]// 
23       begin 
24        If R[J] < R[K] Then K := J 
25       end; 
26      If K <> I Then //交换 R 和 R[K] // 
27        begin Temp := R; R := R[K]; R[K] := Temp; end; 
28     end 
29  End; //SelectSort // 
复制代码 
 
三、冒泡排序(BubbleSort) 
1. 基本思想： 
  两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没
有反序的数据元素为止。 
2. 排序过程： 
  设想被排序的数组 R［1..N］垂直竖立，将每个数据元素看作有重量的气泡，根据轻气
泡不能在重气泡之下的原则，从下往上扫描数组 R，凡扫描到违反本原则的轻气泡，就使其
向上"漂浮"，如此反复进行，直至最后任何两个气泡都是轻者在上，重者在下为止。 
【示例】： 
49 13 13 13 13 13 13 13 
38 49 27 27 27 27 27 27 
65 38 49 38 38 38 38 38 
97 65 38 49 49 49 49 49 
76 97 65 49 49 49 49 49 
13 76 97 65 65 65 65 65 
27 27 76 97 76 76 76 76 
49 49 49 76 97 97 97 97 
 
30 
31Procedure BubbleSort(Var R : FileType) //从下往上扫描的起泡排序// 
32Begin 
33  For I := 1 To N-1 Do //做 N-1 趟排序// 
34   begin 
35     NoSwap := True; //置未排序的标志// 
36     For J := N - 1 DownTo 1 Do //从底部往上扫描// 
37      begin 
38       If R[J+1]< R[J] Then //交换元素// 
39        begin 
40         Temp := R[J+1]; R[J+1 := R[J]; R[J] := Temp; 
41         NoSwap := False 
42        end; 
43      end; 
44     If NoSwap Then Return//本趟排序中未发生交换，则终止算法// 
45    end 
46End; //BubbleSort// 
复制代码 
 
 
四、快速排序（Quick Sort） 
1. 基本思想： 
  在当前无序区 R[1..H]中任取一个数据元素作为比较的"基准"(不妨记为 X)，用此基准将
当前无序区划分为左右两个较小的无序区：R[1..I-1]和 R[I+1..H]，且左边的无序子区中数据元
素均小于等于基准元素，右边的无序子区中数据元素均大于等于基准元素，而基准 X 则位于
最终排序的位置上，即 R[1..I-1]≤X.Key≤R[I+1..H](1≤I≤H)，当 R[1..I-1]和 R[I+1..H]均非空时，分
别对它们进行上述的划分过程，直至所有无序子区中的数据元素均已排序为止。 
2. 排序过程： 
【示例】： 
初始关键字 [49 38 65 97 76 13 27 49］ 
第一次交换后 
［27 38 65 97 76 13 49 49］ 
第二次交换后 
［27 38 49 97 76 13 65 49］ 
J 向左扫描，位置不变，第三次交换后 
［27 38 13 97 76 49 65 49］ 
I 向右扫描，位置不变，第四次交换后 
［27 38 13 49 76 97 65 49］ 
J 向左扫描 
［27 38 13 49 76 97 65 49］ 
（一次划分过程） 
 
初始关键字 
［49 38 65 97 76 13 27 49］ 
一趟排序之后 
［27 38 13］ 49 ［76 97 65 49］ 
二趟排序之后 
［13］ 27 ［38］ 49 ［49 65］76 ［97］ 
三趟排序之后 13 27 38 49 49 ［65］76 97 
最后的排序结果 13 27 38 49 49 65 76 97 
各趟排序之后的状态 
 
47 
48Procedure Parttion(Var R : FileType; L, H : Integer; Var I : Integer); 
49//对无序区 R[1,H]做划分，I 给以出本次划分后已被定位的基准元素的位置 // 
50Begin 
51  I := 1; J := H; X := R ;//初始化，X 为基准// 
52  Repeat 
53    While (R[J] >= X) And (I < J) Do 
54      begin 
55       J := J - 1 //从右向左扫描，查找第 1 个小于 X 的元素// 
56       If I < J Then //已找到 R[J] 〈X// 
57         begin 
58          R := R[J]; //相当于交换 R 和 R[J]// 
59          I := I + 1 
60         end; 
61       While (R <= X) And (I < J) Do 
62          I := I + 1 //从左向右扫描，查找第 1 个大于 X 的元素/// 
63      end; 
64     If I < J Then //已找到 R > X // 
65       begin         R[J] := R; //相当于交换 R 和 R[J]// 
66        J := J - 1 
67       end 
68  Until I = J; 
69  R := X //基准 X 已被最终定位// 
70End; //Parttion // 
复制代码 
71 
72Procedure QuickSort(Var R :FileType; S,T: Integer); //对 R[S..T]快速排序// 
73Begin 
74  If S < T Then //当 R[S..T]为空或只有一个元素是无需排序// 
75    begin 
76      Partion(R, S, T, I); //对 R[S..T]做划分// 
77      QuickSort(R, S, I-1);//递归处理左区间 R[S,I-1]// 
78      QuickSort(R, I+1,T);//递归处理右区间 R[I+1..T] // 
79    end; 
80End; //QuickSort// 
复制代码 
 
 
五、堆排序(Heap Sort) 
1. 基本思想： 
堆排序是一树形选择排序，在排序过程中，将 R[1..N]看成是一颗完全二叉树的顺序存储结
构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。 
2. 堆的定义: N 个元素的序列 K1,K2,K3,...,Kn.称为堆，当且仅当该序列满足特性： 
       Ki≤K2i Ki ≤K2i+1(1≤ I≤ [N/2]) 
 
 
堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均大于等于其孩子结
点的关键字。例如序列 10,15,56,25,30,70 就是一个堆，它对应的完全二叉树如上图所示。这
种堆中根结点（称为堆顶）的关键字最小，我们把它称为小根堆。反之，若完全二叉树中任
一非叶子结点的关键字均大于等于其孩子的关键字，则称之为大根堆。 
3. 排序过程： 
堆排序正是利用小根堆（或大根堆）来选取当前无序区中关键字小（或最大）的记录实现排
序的。我们不妨利用大根堆来排序。每一趟排序的基本操作是：将当前无序区调整为一个大
根堆，选取关键字最大的堆顶记录，将它和无序区中的最后一个记录交换。这样，正好和直
接选择排序相反，有序区是在原记录区的尾部形成并逐步向前扩大到整个记录区。 
【示例】：对关键字序列 42，13，91，23，24，16，05，88 建堆 
 
81 
82Procedure Sift(Var R :FileType; I, M : Integer); 
83//在数组 R[I..M]中调用 R，使得以它为完全二叉树构成堆。事先已知其左、右子树(2I+1 <=M
时)均是堆// 
84Begin 
85  X := R; J := 2*I; //若 J <=M, R[J]是 R 的左孩子// 
86  While J <= M Do //若当前被调整结点 R 有左孩子 R[J]// 
87   begin 
88    If (J < M) And R[J].Key < R[J+1].Key Then 
89      J := J + 1 //令 J 指向关键字较大的右孩子// 
90        //J 指向 R 的左、右孩子中关键字较大者// 
91    If X.Key < R[J].Key Then //孩子结点关键字较大// 
92      begin 
93        R := R[J]; //将 R[J]换到双亲位置上// 
94        I := J ; J := 2*I //继续以 R[J]为当前被调整结点往下层调整// 
95      end; 
96     Else 
97      Exit//调整完毕，退出循环// 
98   end 
99  R := X;//将最初被调整的结点放入正确位置// 
100End;//Sift// 
复制代码 
101  Procedure HeapSort(Var R : FileType); //对 R[1..N]进行堆排序// 
102 Begin 
103  For I := N Div Downto 1 Do //建立初始堆// 
104   Sift(R, I , N) 
105  For I := N Downto 2 do //进行 N-1 趟排序// 
106   begin 
107    T := R[1]; R[1] := R; R := T;//将当前堆顶记录和堆中最后一个记录交换// 
108    Sift(R, 1, I-1) //将 R[1..I-1]重成堆// 
109   end 
110End; //HeapSort// 
复制代码 
 
 
六、几种排序算法的比较和选择 
1. 选取排序方法需要考虑的因素： 
(1) 待排序的元素数目 n； 
(2) 元素本身信息量的大小； 
(3) 关键字的结构及其分布情况； 
(4) 语言工具的条件，辅助空间的大小等。 
2. 小结： 
(1) 若 n 较小(n <= 50)，则可以采用直接插入排序或直接选择排序。由于直接插入排序所需
的记录移动操作较直接选择排序多，因而当记录本身信息量较大时，用直接选择排序较好。 
(2) 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。 
(3) 若 n 较大，则应采用时间复杂度为 O(nlog2n)的排序方法：快速排序、堆排序或归并排序。 
快速排序是目前基于比较的内部排序法中被认为是最好的方法。 
(4) 在基于比较排序方法中，每次比较两个关键字的大小之后，仅仅出现两种可能的转移，
因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的 n 个关键字随机分布
时，任何借助于"比较"的排序算法，至少需要 O(nlog2n)的时间。 
 
这句话很重要 它告诉我们自己写的算法 是有改进到最优 当然没有必要一直追求最优 
(5) 当记录本身信息量较大时，为避免耗费大量时间移动记录，可以用链表作为存储结构。 
 
 
 
真题回顾 
（2014 年真题 单选题 第 57 题）对线性表（45,35,65,85,75,15,25）进行一趟冒泡排序后的
结果是（     ）      
A.(35,45,65,85,75,15,25)       B.(15,35,25,45,75,85,65) 
C.(45,35,25,15,75,85,65)       D.(35,45,65,75,15,25,85) 
 
（2014年真题 单选题 第56题）对任意一棵具有 n 个结点的树，树中所包含的边数是（   ） 
A. n     B.n-2     C.n-1   D.n+1 
 
（2014 年真题 多选题 第 82 题）下列排序算法中，比较次数与初始排列状态有关的算法有
（    ） 
A.冒泡排序  B.快速排序  C.直接插入排序  D.简单选择排序 
 
（2016 年上半年真题 单选题 第 66 题）某单位按照编号、姓名、工资等信息建立职工信息
表，且已按照姓名排好序，如果要快速地按照姓名查找到某职工的工资，最快的查找法是（  ）。 
A、顺序查找   B、折半查找  C、哈希查找   D、索引查找 
 
（2017 年上半年真题 单选题 第 67 题）图是一种可以用来解决复杂路由问题的抽象数据类
型，图的遍历可以不重复的访问给定图中的所有顶点，当从图的第一个顶点开始任意一个和
它相邻的子顶点进行处理，知道某一顶点没有相邻子顶点，知道遍历完所有顶点，该方法称
为（）。 
A. 随机遍历   
B. 后序遍历   
C. 深度优先遍历  
D. 广度优先遍历 
 
 
（2019 年真题 单选题 第 64 题）从数据结构的角度来看，某用户微信好友之间的关系所表
示的逻辑结构是：（   ） 
A.队列      B.栈   C.树    D.图 
 
 
复习题 
 
（1）树和二叉树的区别和联系有哪些？ 
（2）图的分类有哪些？ 
（3）选择排序和插入排序、冒泡排序、快速排序分别是如何完成的。 
 
 
复习题 
 
（1）树和二叉树的区别和联系有哪些？ 
答：树和二叉树的区别：1、两者性质不同：树是一种数据结构；二叉树是每个结点最多有
两个子树的一种树结构。2、结点数目不同：树的每个结点有零个或多个子结点；没有父结
点的结点称为根结点；每一个非根结点有且只有一个父结点。 
 
树和二叉树的联系：树都可用二叉链表作为存储结构，对比各自的结点结构可以看出，以二
叉链表作为媒介可以导出树和二叉树之间的一个对应关系。从物理结构来看，树和二叉树的
二叉链表是相同的，只是对指针的逻辑解释不同而已。 
 
2）图的分类有哪些？ 
答：首先可以按有向无向来进行分类。可以分为无向图和有向图。需要注意的是，无向图的
计算式实现实际上是内存里存储了两个方向的有向图。所以可以把无向图看成双向的有向图。
有向图的例子很多，流程图或者更确切的例子是工作流，就是有向图。面向对象程序的内存
结构也是一个有向图。 
 
有很少条边或弧的图称为稀疏图，反之称为稠密图（相对而言） 
 
有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫作权（Weight）。 
这些权可以表示从一个顶点到另一个顶点的距离或者损耗。 
带权的图通常称为网。 
 
（3）选择排序和插入排序、冒泡排序、快速排序分别是如何完成的。 
答：选择排序： 
  每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数
列的最后，直到全部待排序的数据元素排完。 
 
插入排序(Insertion Sort)： 
每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有
序；直到待排序数据元素全部插入完为止。 
 
冒泡排序(BubbleSort)： 
  两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没
有反序的数据元素为止。 
 
快速排序（Quick Sort）： 
  在当前无序区 R[1..H]中任取一个数据元素作为比较的"基准"(不妨记为 X)，用此基准将
当前无序区划分为左右两个较小的无序区：R[1..I-1]和 R[I+1..H]，且左边的无序子区中数据元
素均小于等于基准元素，右边的无序子区中数据元素均大于等于基准元素，而基准 X 则位于
最终排序的位置上，即 R[1..I-1]≤X.Key≤R[I+1..H](1≤I≤H)，当 R[1..I-1]和 R[I+1..H]均非空时，分
别对它们进行上述的划分过程，直至所有无序子区中的数据元素均已排序为止。 
 
